generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String                @id @default(cuid())
  address        String                @unique
  username       String?
  points         Int                   @default(0)
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  participations BattleParticipation[]
  wins           BattleWin[]
  casts          Cast[]

  @@map("users")
}

model Battle {
  id               String                @id @default(cuid())
  title            String
  description      String
  category         String
  source           String
  sourceUrl        String?
  status           BattleStatus          @default(ACTIVE)
  startTime        DateTime
  endTime          DateTime
  durationHours    Float
  maxParticipants  Int                   @default(1000)
  debatePoints     Json
  overallScore     Int?
  balanceScore     Int?
  complexity       String?
  controversyLevel String?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  imageUrl         String?  // Production image URL from Serper API
  thumbnail        String?  // Production thumbnail URL from Serper API
  history          BattleHistory?
  participants     BattleParticipation[]
  winners          BattleWin[]
  casts            Cast[]

  @@map("battles")
}

model BattleParticipation {
  id       String   @id @default(cuid())
  userId   String
  battleId String
  joinedAt DateTime @default(now())
  battle   Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, battleId])
  @@map("battle_participations")
}

model Cast {
  id             String   @id @default(cuid())
  userId         String
  battleId       String
  content        String
  side           CastSide
  qualityScore   Int?
  relevanceScore Int?
  isAppropriate  Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  battle         Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("casts")
}

model BattleWin {
  id       String  @id @default(cuid())
  battleId String
  userId   String
  position Int
  prize    String?
  battle   Battle  @relation(fields: [battleId], references: [id], onDelete: Cascade)
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([battleId, position])
  @@map("battle_wins")
}

model BattleHistory {
  id                String   @id @default(cuid())
  battleId          String   @unique
  completedAt       DateTime @default(now())
  totalParticipants Int
  totalCasts        Int
  winnerAddress     String?
  battle            Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)

  @@map("battle_history")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value String

  @@map("system_config")
}

model SharedState {
  id                String    @id @default(cuid())
  key               String    @unique
  rateLimitCooldown DateTime?
  lastUpdated       DateTime  @default(now())
  createdAt         DateTime  @default(now())

  @@map("shared_state")
}

enum BattleStatus {
  PREPARING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum CastSide {
  SUPPORT
  OPPOSE
}
