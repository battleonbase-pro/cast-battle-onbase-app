// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Connection pooling configuration for production
  // These settings help prevent connection pool timeouts
  // connection_limit = 20
  // pool_timeout = 20
}

model User {
  id        String   @id @default(cuid())
  address   String   @unique
  username  String?
  points    Int      @default(0)  // Points earned from participation
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participations BattleParticipation[]
  wins          BattleWin[]
  casts         Cast[]

  @@map("users")
}

model Battle {
  id          String      @id @default(cuid())
  title       String
  description String
  category    String
  source      String
  sourceUrl   String?     // URL to the original news article
  status      BattleStatus @default(ACTIVE)
  
  // Battle timing
  startTime   DateTime
  endTime     DateTime
  durationHours Float  // Intended duration in hours (stored for historical accuracy)
  
  // Battle configuration
  maxParticipants Int @default(1000)
  
  // Debate points (stored as JSON)
  debatePoints    Json
  
  // Quality metrics
  overallScore    Int?
  balanceScore    Int?
  complexity      String?
  controversyLevel String?
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  participants BattleParticipation[]
  casts        Cast[]
  winners      BattleWin[]
  history      BattleHistory?

  @@map("battles")
}

model BattleParticipation {
  id        String   @id @default(cuid())
  userId    String
  battleId  String
  joinedAt  DateTime @default(now())
  
  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  battle Battle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  
  @@unique([userId, battleId])
  @@map("battle_participations")
}

model Cast {
  id        String   @id @default(cuid())
  userId    String
  battleId  String
  content   String
  side      CastSide // SUPPORT or OPPOSE
  
  // Quality metrics
  qualityScore   Int?
  relevanceScore Int?
  isAppropriate  Boolean @default(true)
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  battle Battle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  
  @@map("casts")
}

model BattleWin {
  id        String   @id @default(cuid())
  battleId  String
  userId    String
  position  Int      // 1st, 2nd, 3rd place
  prize     String?  // Prize amount or description
  
  // Relations
  battle Battle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([battleId, position])
  @@map("battle_wins")
}

model BattleHistory {
  id          String   @id @default(cuid())
  battleId    String   @unique
  completedAt DateTime @default(now())
  
  // Summary data for quick access
  totalParticipants Int
  totalCasts        Int
  winnerAddress     String?
  
  // Relations
  battle Battle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  
  @@map("battle_history")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value String
  
  @@map("system_config")
}

model SharedState {
  id                String    @id @default(cuid())
  key               String    @unique
  rateLimitCooldown DateTime?
  lastUpdated       DateTime  @default(now())
  createdAt         DateTime  @default(now())
  
  @@map("shared_state")
}

enum BattleStatus {
  PREPARING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum CastSide {
  SUPPORT
  OPPOSE
}