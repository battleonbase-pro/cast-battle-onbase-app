import { ethers, providers } from 'ethers';
import { Wallet, types } from './index';
import { Provider } from './provider';
/**
 * Gateway presets for mainnet and testnet.
 * @public
 */
export declare const GATEWAY_PRESETS: Readonly<Record<'testnet' | 'mainnet', {
    chainId: bigint;
    rpcUrl: string;
}>>;
/**
 * Resolve a Gateway provider + chainId from a flexible config.
 *
 * Precedence:
 * 1) explicit `gwProvider` + `gwChainId`
 * 2) `env` ('testnet' | 'mainnet') with optional overrides
 * 3) `env: 'local'` requires `gwRpcUrl` and `gwChainId` (or explicit provider + chainId)
 *
 * @public
 * @param config - Flexible Gateway configuration. Defaults to the **testnet** preset.
 * @returns `{ gwProvider, gwChainId }` ready to use.
 * @throws If `env: 'local'` is selected without enough information to construct a provider.
 * @example
 * ```ts
 * const { gwProvider, gwChainId } = resolveGateway(); // testnet by default
 * const onMainnet = resolveGateway({ env: 'mainnet' });
 * const local = resolveGateway({ env: 'local', gwRpcUrl: 'http://localhost:3250', gwChainId: 506n });
 * ```
 */
export declare function resolveGateway(config?: types.GatewayConfig): {
    gwProvider: providers.JsonRpcProvider;
    gwChainId: bigint;
};
export declare class InteropClient {
    /** Resolved Gateway provider used for batch→GW block mapping. */
    readonly gwProvider: providers.JsonRpcProvider;
    /** Resolved Gateway chain id used for root lookups on target chains. */
    readonly gwChainId: bigint;
    constructor(opts?: {
        gateway?: types.GatewayConfig;
    });
    /**
     * Send a message via the L1Messenger on the source chain and return the `Sent` bundle.
     *
     * @param srcWallet - Wallet connected to the source L2.
     * @param message   - Bytes or string; strings are UTF-8 encoded.
     *
     * @returns txHash — The transaction hash.
     */
    sendMessage(srcWallet: Wallet, message: ethers.BytesLike | string): Promise<{
        txHash: `0x${string}`;
    }>;
    /**
     * Verify inclusion of a previously sent message on a target chain.
     * This is a read-only check against the target's L2MessageVerification contract.
     *
     * @param params.txHash         - Returned txHash from `sendMessage`.
     * @param params.srcProvider  - Provider for the source chain (to fetch proof nodes + batch details).
     * @param params.targetChain   - Provider for the target chain (to read interop roots + call verifier). This can be any chain that imports the Gateway roots.
     * @param params.includeProofInputs - If true, include raw proof positioning info in the result (for debugging).
     * @param params.timeoutMs         - Max time to wait for the interop root on the target chain (ms). Default: 120_000.
     * @returns InteropResult — compact verification outcome (plus optional proof inputs).
     */
    verifyMessage(params: {
        txHash: `0x${string}`;
        srcProvider: Provider;
        targetChain: Provider;
        includeProofInputs?: boolean;
        timeoutMs?: number;
    }): Promise<types.InteropResult>;
    /**
     * Get the input arguments for proveL2MessageInclusionShared to verify a previously sent message on a target chain.
     *
     * @param params.txHash         - Returned txHash from `sendMessage`.
     * @param params.srcProvider  - Provider for the source chain (to fetch proof nodes + batch details).
     * @param params.targetChain   - Provider for the target chain (to read interop roots + call verifier). This can be any chain that imports the Gateway roots.
     * @param params.includeProofInputs - If true, include raw proof positioning info in the result (for debugging).
     * @param params.timeoutMs         - Max time to wait for the interop root on the target chain (ms). Default: 120_000.
     * @returns ProveL2MessageInclusionSharedArgs & { interopRoot: string; gwBlock?: bigint; l2ToL1LogIndex?: number; } - An object with all the required input arguments to verify a previously sent message using the proveL2MessageInclusionShared method on the target's L2MessageVerification contract.
     */
    getVerificationArgs(params: {
        txHash: `0x${string}`;
        srcProvider: Provider;
        targetChain: Provider;
        includeProofInputs?: boolean;
        timeoutMs?: number;
    }): Promise<types.ProveL2MessageInclusionSharedArgs & {
        interopRoot?: string;
        gwBlock?: bigint;
        l1BatchTxIndex?: number;
        l2ToL1LogIndex?: number;
    }>;
    /**
     * Check the current lifecycle phase of a sent message on the source chain.
     *
     * @param srcProvider - Source chain provider (supports `getTransactionDetails`).
     * @param txHash      - Transaction hash returned by {@link sendMessage}.
     * @returns Phase classification:
     *   'QUEUED' | 'SENDING' | 'PROVING' | 'EXECUTED' | 'FAILED' | 'REJECTED' | 'UNKNOWN'
     */
    getMessageStatus(srcProvider: Provider, txHash: `0x${string}`): Promise<"QUEUED" | "SENDING" | "PROVING" | "EXECUTED" | "FAILED" | "REJECTED" | "UNKNOWN" | {
        phase: string;
        message: "No details available";
    }>;
}
