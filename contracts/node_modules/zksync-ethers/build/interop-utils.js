"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.classifyPhase = exports.waitForGatewayInteropRoot = exports.getGwBlockForBatch = exports.getGatewayProof = exports.findInteropLogIndex = void 0;
// src/interop-utils.ts
const ethers_1 = require("ethers");
const index_1 = require("./index");
/**
 * Locate the L1Messenger service log inside a receipt.
 *
 * Matches by:
 * - `sender == L1_MESSENGER_ADDRESS`
 * - `key == zeroPad(eoa, 32)`
 * - optional `value == keccak256(message)` if `message` is provided
 *
 * @internal
 * @param receipt - Source L2 tx receipt with `l2ToL1Logs`.
 * @param sender - Externally owned account (sender) to match.
 * @returns The log index within `receipt.l2ToL1Logs`, or `-1` if not found and whether or not the message was sent inside a contract.
 */
function findInteropLogIndex(receipt, sender) {
    const paddedSender = ethers_1.ethers.utils.hexZeroPad(sender, 32);
    const paddedContract = receipt.to
        ? ethers_1.ethers.utils.hexZeroPad(receipt.to, 32)
        : null;
    let messageSentInContract = false;
    const l2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((log) => {
        const senderMatches = log.sender.toLowerCase() === index_1.utils.L1_MESSENGER_ADDRESS.toLowerCase();
        const keyMatchesEOASender = log.key.toLowerCase() === paddedSender.toLowerCase();
        const keyMatchesContractSender = paddedContract && log.key.toLowerCase() === paddedContract.toLowerCase();
        if (senderMatches && (keyMatchesEOASender || keyMatchesContractSender)) {
            if (keyMatchesContractSender) {
                messageSentInContract = true;
            }
            return true;
        }
        return false;
    });
    return { l2ToL1LogIndex, messageSentInContract };
}
exports.findInteropLogIndex = findInteropLogIndex;
/**
 * Fetch the Gateway proof nodes for a specific source tx/log.
 *
 * Uses the provider’s `zks_getL2ToL1LogProof` with interop mode set to `"proof_based_gw"`,
 * i.e. the proof targets the Gateway’s Merkle root.
 *
 * @internal
 * @param l2 - Source chain provider.
 * @param txHash - Source tx hash.
 * @param logIndex - Index within `receipt.l2ToL1Logs`.
 * @returns Array of Merkle nodes (bytes32[]).
 * @throws If the proof is not ready yet on the source node.
 */
async function getGatewayProof(l2, txHash, logIndex) {
    const proofResp = await l2.getLogProof(txHash, logIndex, 'proof_based_gw');
    if (!(proofResp === null || proofResp === void 0 ? void 0 : proofResp.proof) || proofResp.proof.length === 0) {
        throw new Error('Gateway proof not ready yet. Ensure the transaction is settled on Gateway.');
    }
    return { nodes: proofResp.proof, proofId: proofResp.id };
}
exports.getGatewayProof = getGatewayProof;
/**
 * Map an L1 batch number → the Gateway block that executed that batch.
 *
 * Implementation detail:
 * - Reads `executeTxHash` from `zks_getL1BatchDetails`
 * - Looks up its receipt on the Gateway to get the `blockNumber`
 * - Polls until available (useful shortly after batch execution)
 *
 * @internal
 * @param batch - L1 batch number.
 * @param l2 - Source chain provider.
 * @param gw - Gateway provider.
 * @param pollMs - Poll interval (ms). Default: 1000.
 * @returns Gateway block number as bigint.
 */
async function getGwBlockForBatch(batch, l2, gw, pollMs = 1000) {
    for (;;) {
        const details = await l2.getL1BatchDetails(Number(batch));
        const exec = (details === null || details === void 0 ? void 0 : details.executeTxHash) &&
            details.executeTxHash !== ethers_1.ethers.constants.HashZero
            ? details.executeTxHash
            : null;
        if (exec) {
            const r = await gw.getTransactionReceipt(exec);
            if ((r === null || r === void 0 ? void 0 : r.blockNumber) !== undefined)
                return BigInt(r.blockNumber);
        }
        await index_1.utils.sleep(pollMs);
    }
}
exports.getGwBlockForBatch = getGwBlockForBatch;
/**
 * Wait until a target chain has imported the Gateway interop root for a given Gateway block.
 *
 * Reads `L2_INTEROP_ROOT_STORAGE.interopRoots(gwChainId, gwBlock)` until non-zero.
 * This is a **poll-only** method; the public API hides timing knobs and uses defaults here.
 *
 * Notes for local development:
 * - If you see this timing out, your target chain may not have sealed the block yet.
 *   Trigger sealing (e.g. by sending any small L2 tx) and retry.
 *
 * @internal
 * @param gwChainId - Gateway chain id (bigint).
 * @param target - Target chain provider.
 * @param gwBlock - Gateway block number.
 * @param options.timeoutMs - Timeout (ms). Default: 120_000.
 * @param options.pollMs - Poll interval (ms). Default: 1500.
 * @returns Imported interop root (bytes32 as hex string).
 * @throws If the interop root is not imported in time.
 */
async function waitForGatewayInteropRoot(gwChainId, target, gwBlock, { timeoutMs = 120000, pollMs = 1500, } = {}) {
    const interop = new ethers_1.ethers.Contract(index_1.utils.L2_INTEROP_ROOT_STORAGE_ADDRESS, index_1.utils.L2_INTEROP_ROOT_STORAGE_ABI, target);
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
        const root = await interop.interopRoots(gwChainId, gwBlock);
        if (root && root !== '0x' + '0'.repeat(64))
            return root;
        await index_1.utils.sleep(pollMs);
    }
    throw new Error(`Target chain did not import interop root for (${gwChainId}, ${gwBlock}) or block has not been sealed yet`);
}
exports.waitForGatewayInteropRoot = waitForGatewayInteropRoot;
function classifyPhase(d) {
    if (d.status === 'failed')
        return 'FAILED';
    if (d.status === 'rejected')
        return 'REJECTED';
    if (['included', 'fastFinalized', 'verified'].includes(d.status)) {
        if (d.ethExecuteTxHash)
            return 'EXECUTED';
        if (d.ethProveTxHash)
            return 'PROVING';
        if (d.ethCommitTxHash)
            return 'SENDING';
        return 'QUEUED';
    }
    return 'UNKNOWN';
}
exports.classifyPhase = classifyPhase;
//# sourceMappingURL=interop-utils.js.map