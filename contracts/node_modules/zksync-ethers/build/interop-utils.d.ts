import { ethers, providers } from 'ethers';
import { types } from './index';
import { Provider } from './provider';
import { BatchPhase, TxDetailsLite } from './types';
/**
 * Locate the L1Messenger service log inside a receipt.
 *
 * Matches by:
 * - `sender == L1_MESSENGER_ADDRESS`
 * - `key == zeroPad(eoa, 32)`
 * - optional `value == keccak256(message)` if `message` is provided
 *
 * @internal
 * @param receipt - Source L2 tx receipt with `l2ToL1Logs`.
 * @param sender - Externally owned account (sender) to match.
 * @returns The log index within `receipt.l2ToL1Logs`, or `-1` if not found and whether or not the message was sent inside a contract.
 */
export declare function findInteropLogIndex(receipt: types.TransactionReceipt, sender: types.Address): {
    l2ToL1LogIndex: number;
    messageSentInContract: boolean;
};
/**
 * Fetch the Gateway proof nodes for a specific source tx/log.
 *
 * Uses the provider’s `zks_getL2ToL1LogProof` with interop mode set to `"proof_based_gw"`,
 * i.e. the proof targets the Gateway’s Merkle root.
 *
 * @internal
 * @param l2 - Source chain provider.
 * @param txHash - Source tx hash.
 * @param logIndex - Index within `receipt.l2ToL1Logs`.
 * @returns Array of Merkle nodes (bytes32[]).
 * @throws If the proof is not ready yet on the source node.
 */
export declare function getGatewayProof(l2: Provider, txHash: ethers.BytesLike, logIndex: number): Promise<{
    nodes: string[];
    proofId: number;
}>;
/**
 * Map an L1 batch number → the Gateway block that executed that batch.
 *
 * Implementation detail:
 * - Reads `executeTxHash` from `zks_getL1BatchDetails`
 * - Looks up its receipt on the Gateway to get the `blockNumber`
 * - Polls until available (useful shortly after batch execution)
 *
 * @internal
 * @param batch - L1 batch number.
 * @param l2 - Source chain provider.
 * @param gw - Gateway provider.
 * @param pollMs - Poll interval (ms). Default: 1000.
 * @returns Gateway block number as bigint.
 */
export declare function getGwBlockForBatch(batch: bigint, l2: Provider, gw: providers.JsonRpcProvider, pollMs?: number): Promise<bigint>;
/**
 * Wait until a target chain has imported the Gateway interop root for a given Gateway block.
 *
 * Reads `L2_INTEROP_ROOT_STORAGE.interopRoots(gwChainId, gwBlock)` until non-zero.
 * This is a **poll-only** method; the public API hides timing knobs and uses defaults here.
 *
 * Notes for local development:
 * - If you see this timing out, your target chain may not have sealed the block yet.
 *   Trigger sealing (e.g. by sending any small L2 tx) and retry.
 *
 * @internal
 * @param gwChainId - Gateway chain id (bigint).
 * @param target - Target chain provider.
 * @param gwBlock - Gateway block number.
 * @param options.timeoutMs - Timeout (ms). Default: 120_000.
 * @param options.pollMs - Poll interval (ms). Default: 1500.
 * @returns Imported interop root (bytes32 as hex string).
 * @throws If the interop root is not imported in time.
 */
export declare function waitForGatewayInteropRoot(gwChainId: bigint, target: Provider, gwBlock: bigint, { timeoutMs, pollMs, }?: {
    timeoutMs?: number;
    pollMs?: number;
}): Promise<string>;
export declare function classifyPhase(d: TxDetailsLite): BatchPhase;
